<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
<TITLE>Глава 14</TITLE>
</HEAD>

<body bgcolor="#FFFFFF">
<basefont face="Times New Roman, sans-serif, Courier, mono" size="3">
<h3 align="center"><B><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="6"> 
  Часть VI. Сети и сетевые операционные системы</FONT></B></h3>
<P ALIGN="CENTER"><B><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="4"><a name="l1400"></a>Глава 
  14. Сети и сетевые операционные системы</FONT></B></P>

<p align="center"><a href="../13/ch13.htm"> Предыдущая глава</a> | 
<a href="../os.html">Программа курса</a> | 
<a href="../15/ch15.htm"> Следующая глава</a></p>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">
<table width="100%" border="0" cellspacing="1" cellpadding="1">
  <tr> 
    <td width="50%">&nbsp;</td>
    <td> 
      <P ALIGN="JUSTIFY"><i><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">&quot;Чтобы 
        сделать сеть менее заметной и вместе с тем более долговечной, хорошо положить 
        ее в вареное льняное масло, в котором распущено незначительное количество 
        зеленой масляной краски, до тех пор, пока нитки не пропитаются этим составом 
        насквозь. Тогда следует сетку вынуть, дать маслу стечь, хорошенько встряхнуть 
        ее, чтобы по возможности удалить излишек масла, высушить и повторить ту 
        же операцию.&quot; </font></i>
    </td>
  </tr>
  <tr> 
    <td width="50%">&nbsp;</td>
    <td> 
      <div align="right"><i>&quot;Рыболовный календарь&quot; С.П. Сабанеев</i></div>
    </td>
  </tr>
</table>
</font>
<br><P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">
<table width="100%" border="0" cellspacing="1" cellpadding="1">
  <tr> 
    <td width="50%">&nbsp;</td>
    <td><i>&quot;Прибежали в избу дети,<br>
      Второпях зовут отца:<br>
      &laquo;Тятя, тятя, наши сети<br>
      Притащили мертвеца!&raquo;&quot;</i></td>
  </tr>
  <tr> 
    <td width="50%">&nbsp;</td>
    <td> 
      <div align="right"><i>А.С.&nbsp;Пушкин</i></div>
    </td>
  </tr>
</table>
</font>
<br>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">До 
  сих пор все наше рассмотрение ограничивалось рамками классических операционных 
  систем, т.е. операционных систем, функционирующих на автономных однопроцессорных 
  вычислительных машинах, которые к середине 80-х годов прошлого века составляли 
  основу мирового парка вычислительной техники. Подчиняясь критериям повышения 
  эффективности и удобства использования, вычислительные системы с этого времени, 
  о чем мы уже упоминали в самой первой главе, начинают бурно развиваться в двух 
  направлениях: создание многопроцессорных компьютеров и объединение автономных 
  систем в вычислительные сети. <br>
  <br>
  Появление многопроцессорных компьютеров не оказывает серьезного влияния на работу 
  операционных систем. В многопроцессорной вычислительной системе изменяется содержание 
  состояния <i><b>исполнение</b></i>. В этом состоянии может находиться не один 
  процесс, а несколько - по числу процессоров. Соответственно изменяются и алгоритмы 
  планирования. Наличие нескольких исполняющихся процессов требует более аккуратной 
  реализации взаимоисключений при работе ядра. Но все эти изменения не являются 
  изменениями идеологическими, не носят принципиального характера. Принципиальные 
  изменения в многопроцессорных вычислительных комплексах затрагивают алгоритмический 
  уровень, требуя разработки алгоритмов распараллеливания решения задач. Поскольку, 
  с точки зрения нашего курса, многопроцессорные системы не являются системами, 
  привнесшими в операционные системы что-либо принципиально новое, мы их рассматривать 
  далее не будем.<br>
  <br>
  По-другому обстоит дело с вычислительными сетями.<br><br></FONT></P>

<P ALIGN="CENTER"> <B><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"><a name="l1401"></a>14.1. 
  Для чего компьютеры объединяют в сети.</FONT></B> 
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"> 
  Для чего вообще потребовалось объединять компьютеры в сети? Какие причины привели 
  к их появлению? </FONT>
<dir>  
  <ul type="square">
    <li> 
      <P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"> 
        Одной из главных причин стала необходимость разделения ресурсов. Если 
        в какой-либо организации имеется несколько компьютеров, и эпизодически 
        возникает потребность в печати какого-нибудь текста, то глупо покупать 
        принтер для каждого компьютера. Гораздо выгоднее иметь один сетевой принтер 
        для всех вычислительных машин. Аналогичная ситуация может возникать и 
        с файлами данных. Зачем держать одинаковые файлы данных на всех компьютерах, 
        поддерживая их когерентность, если можно держать файл на одной машине, 
        обеспечив к нему сетевой доступ со всех других машин?</font><br>
        <br>
    </li>
    <li>
      <P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"> 
        Второй причиной следует назвать возможность ускорения вычислений. Здесь 
        сетевые объединения машин успешно конкурируют с многопроцессорными вычислительными 
        комплексами. Многопроцессорные системы, не затрагивая по существу строение 
        операционных систем, требуют достаточно серьезных изменений на уровне 
        hardware, что очень сильно повышает их стоимость. Во многих случаях можно 
        добиться требуемой скорости вычислений параллельного алгоритма, используя 
        не несколько процессоров внутри одного вычислительного комплекса, а несколько 
        отдельных компьютеров, связанных в сеть. Такие сетевые вычислительные 
        кластеры часто выигрывают состязание у многопроцессорных комплексов по 
        критерию эффективность/стоимость.<br>
        <br></font>
    </li>
    <li>
      <P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"> 
        Следующая причина связана с повышением надежности работы вычислительной 
        техники. В системах, где отказ может вызвать катастрофические последствия 
        (атомная энергетика, космонавтика, авиация и т.д.), несколько вычислительных 
        комплексов устанавливаются в связи, дублируя друг друга. При выходе из 
        строя основного комплекса его работу немедленно продолжает дублирующий. 
        <br>
        <br>
	  
        </font> 
    </li>
 <li>
      <P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"> 
        Наконец, последней по времени появления причиной (но для многих основной 
        по важности) стала возможность применения вычислительных сетей для общения 
        пользователей. Электронные письма практически заменили письма обычные, 
        а использование вычислительной техники для организации электронных или 
        телефонных разговоров уверенно вытесняет обычную телефонную связь. <br>
        <br>
	  
        </font> 
    </li>
 
  </ul>
</dir>
  
  

  
<P ALIGN="CENTER"> <B><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"><a name="l1402"></a>14.2.</FONT><font face="Times New Roman, sans-serif, Courier, mono" size="3"> 
  Сетевые и распределенные операционные системы.</font></B>
<P ALIGN="JUSTIFY"><font face="Times New Roman, sans-serif, Courier, mono" size="3">В 
  <a href="../01/l1.htm">первой главе</a> <a href="../01/ch1.htm#l0102">мы говорили</a>, 
  что существует два основных подхода к организации операционных систем для вычислительных 
  комплексов, связанных в сеть, - это сетевые и распределенные операционные системы. 
  Необходимо отметить, что терминология в этой области еще не устоялась. В некоторых 
  работах все операционные системы, обеспечивающие работу компьютеров в сети, 
  называются распределенными, а в некоторых, наоборот, - сетевыми. Авторы придерживаются 
  той точки зрения, что сетевые и распределенные системы являются принципиально 
  различными. <br>
  <br>
  В сетевых операционных системах пользователи, при необходимости воспользоваться 
  ресурсами другого сетевого компьютера, должны знать о его наличии и уметь это 
  сделать. Каждая машина в сети работает под управлением своей локальной операционной 
  системы, отличающейся от операционной системы автономного компьютера наличием 
  дополнительных сетевых средств (программной поддержкой для сетевых интерфейсных 
  устройств и доступа к удаленным ресурсам), но эти дополнения существенно не 
  меняют структуру операционной системы. <br>
  <br>
  Распределенная система, напротив, внешне выглядит как обычная автономная система. 
  Пользователь не знает и не должен знать, где его файлы хранятся, - на локальной 
  или удаленной машине, и где его программы выполняются. Он может вообще не знать, 
  подключен ли его компьютер к сети. Внутреннее строение распределенной операционной 
  системы имеет существенные отличия от автономных систем. <br>
  <br>
  Изучение строения распределенных операционных систем не входит в рамки нашего 
  курса. Обычно этому посвящены другие учебные курсы - &quot;Advanced operating 
  systems&quot;, как называют их в англоязычных странах, или &quot;Современные 
  операционные системы&quot;, как принято называть их в России. <br>
  <br>
  В этой главе мы, насколько позволяет нам время, затронем вопросы, связанные 
  с сетевыми операционными системами, а именно - какие добавления необходимо сделать 
  в классической операционной системе для объединения компьютеров в сеть. Конечно, 
  вместо одной главы можно написать целую книгу по сетевым операционным системам, 
  поэтому многие аспекты останутся в стороне от нашего рассмотрения, но мы все 
  же постараемся упрощенно остановиться на основных принципиально важных моментах.</font></P>
<P ALIGN="CENTER"> <B><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"><a name="l1403"></a>14.3. 
  Взаимодействие удаленных процессов как основа работы вычислительных сетей.</FONT></B>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Все 
  перечисленные выше цели объединения компьютеров в вычислительные сети не могут 
  быть достигнуты без организации взаимодействия процессов на различных вычислительных 
  системах. Будь то доступ к разделяемым ресурсам или общение через сеть с другим 
  пользователем - все это в своей основе имеет взаимодействие <i>удаленных</i> 
  процессов, т.е. процессов, которые находятся под управлением физически разных 
  операционных систем. Поэтому мы в своей работе сосредоточимся именно на вопросах 
  кооперации таких процессов, в первую очередь, выделив ее отличия от кооперации 
  процессов в одной автономной вычислительной системе (кооперации <i>локальных</i> 
  процессов), о которой мы говорили в главах <a href="../04/l4.htm">4</a>, <a href="../05/l5.htm">5</a> 
  и <a href="../06/l6.htm">6</a>:<br>
  </font>
<dir> 
  <ol>
    <li> 
      <P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"> 
        Изучая взаимодействие локальных процессов, мы разделили средства обмена 
        информацией по объему передаваемых данных между ними и возможности влияния 
        на поведение другого процесса на <a href="../04/ch4.htm#l0402">три различные 
        категории: сигнальные, канальные и разделяемая память</a>. На самом деле 
        во всей этой систематизации присутствовал некоторый элемент лукавства. 
        Мы фактически классифицировали средства связи по виду интерфейса обращения 
        к ним, в то время как реальной физической основой для всех средств связи 
        в том или ином виде являлось разделение памяти. Семафоры представляют 
        собой просто целочисленные переменные, лежащие в разделяемой памяти, к 
        которым посредством системных вызовов, определяющих состав и содержание 
        допустимых операций над ними, могут обращаться различные процессы. Очереди 
        сообщений и pip'ы базируются на буферах ядра операционной системы, которые 
        опять-таки с помощью системных вызовов доступны различным процессам. Иного 
        способа реально передать информацию от процесса к процессу в автономной 
        вычислительной системе просто не существует. Общение удаленных процессов 
        принципиально отличается от ранее рассмотренных случаев. Общей памяти 
        у различных компьютеров физически нет. Удаленные процессы могут обмениваться 
        информацией, только передавая друг другу пакеты данных определенного формата 
        (в виде последовательностей электрических или электромагнитных, включая 
        световые, сигналов) через некоторый физический канал связи или несколько 
        таких каналов, соединяющих компьютеры. Поэтому в основе всех удаленных 
        средств взаимодействия процессов лежит передача структурированных пакетов 
        информации или сообщений.<br>
        <br>
        </font> 
    </li>
    <li> 
      <P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"> 
        Физическая линия связи, соединяющая несколько вычислительных комплексов, 
        является разделяемым ресурсом для всех процессов этих комплексов, которые 
        хотят ее использовать. Если два любых процесса попытаются одновременно 
        передать пакеты информации по одной и той же линии, то в результате интерференции 
        физических сигналов, представляющих эти пакеты, произойдет взаимное искажение 
        передаваемых данных. Для того чтобы избежать возникновения такой ситуации 
        (<a href="../05/ch5.htm#l0501">race condition</a>!) и обеспечить эффективную 
        совместную работу вычислительных систем, необходимо обеспечить выполнение 
        <a href="../05/ch5.htm#l050301">условий взаимоисключения, прогресса и 
        ограниченного ожидания</a> при использовании общей линии связи, но уже 
        не на уровне отдельных процессов операционных систем, а на уровне различных 
        операционных систем в целом. <br>
        <br>
        </font> 
    </li>
    <li> 
      <P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"> 
        При организации взаимодействия локальных процессов каждый процесс (в случае 
        прямой адресации) и каждый промежуточный объект для накопления данных 
        (в случае непрямой адресации) должны были иметь уникальные идентификаторы 
        - адреса - в рамках одной операционной системы. При организации взаимодействия 
        удаленных процессов участники этого взаимодействия должны иметь уникальные 
        адреса уже в рамках всей сети.<br>
        <br>
        </font> 
    </li>
    <li> 
      <P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"> 
        В автономной операционной системе передача информации от одного процесса 
        к другому, независимо от используемого способа адресации, как правило 
        (за исключением микроядерных операционных систем), происходит напрямую 
        - без участия других процессов-посредников. Но даже и при наличии процессов-посредников 
        все участники передачи информации находятся под управлением одной и той 
        же операционной системы. При организации сети, конечно, можно обеспечить 
        прямую связь между всеми вычислительными комплексами, соединив каждый 
        из них со всеми оставшимися комплексами посредством прямых физических 
        линий связи или подключив все комплексы к общей шине (по примеру шин данных 
        и адреса в компьютере). Однако такая сетевая топология не всегда возможна 
        по ряду физических и финансовых причин. Поэтому, во многих случаях, информация 
        между удаленными процессами в сети передается не напрямую, а через ряд 
        процессов-посредников, обитающих на вычислительных комплексах, не являющихся 
        компьютерами отправителя и получателя, и работающих под управлением собственных 
        операционных систем.<br>
        <br>
        </font> 
    </li>
    <li> 
      <P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"> 
        <a href="../04/ch4.htm#l040304">Вопросы надежности средств связи</a>, 
        рассмотренные нами в <a href="../04/l4.htm">главе 4</a>, носили для случая 
        локальных процессов скорее теоретический характер. Мы выяснили, что физической 
        основой общения процессов на автономной вычислительной машине является 
        разделяемая память. Поэтому для локальных процессов надежность передачи 
        информации определяется надежностью ее передачи по шине данных и хранения 
        в памяти машины, а также корректностью работы операционной системы. Для 
        хороших вычислительных комплексов и операционных систем мы могли забыть 
        про возможную ненадежность средств связи. Для удаленных процессов вопросы, 
        связанные с надежностью передачи данных, становятся существенно более 
        значимыми. Протяженные сетевые линии связи подвержены разнообразным физическим 
        воздействиям, приводящим к искажению передаваемых по ним физических сигналов 
        (помехи в эфире) или к полному отказу линий (мыши съели кабель). Даже 
        при отсутствии внешних помех передаваемый сигнал затухает по мере удаления 
        от точки отправления, сравниваясь по интенсивности с внутренними шумами 
        линий связи. Промежуточные вычислительные комплексы сети, участвующие 
        в доставке информации, не застрахованы от выхода из строя или внезапной 
        перезагрузки операционной системы. Поэтому вычислительные сети обязаны 
        организовываться, исходя из предпосылок ненадежности доставки физических 
        пакетов информации.</font> 
    </li>
  </ol>
</dir>
  
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"> 
  Давайте теперь, в очередной раз абстрагировавшись от физического уровня организации 
  связи, не обращая внимания на то какие именно физические средства - оптоволокно, 
  коаксиальный кабель, спутниковая связь и т.д. - лежат в основе объединения компьютеров 
  в сеть, обсудим влияние перечисленных отличий на логические принципы организации 
  взаимодействия удаленных процессов. </font></P>
<P ALIGN="CENTER"> <B><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"><a name="l1404"></a>14.4. 
  Основные вопросы логической организации передачи информации между удаленными 
  процессами.</font></B> 
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"> 
К числу наиболее фундаментальных вопросов, связанных с  логической 
организацией взаимодействия удаленных процессов, следует отнести следующие вопросы:
  </font></p>
  
<dir> 
  <ol>
    <li> 
      <P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"> 
        Как следует соединять между собой различные вычислительные системы физическими 
        линиями связи для организации взаимодействия удаленных процессов? Какими 
        критериями при этом следует пользоваться?</font></p>
    </li>
    <li> 
      <P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"> 
        Как избежать возникновения race condition при передаче информации различными 
        вычислительными системами после их подключения к общей линии связи? Какие 
        алгоритмы могут быть при этом применены?</font></p>
    </li>
    <li> 
      <P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"> 
        Какие подходы существуют для организации адресации удаленных процессов? 
        Насколько они эффективны? </font></p>
    </li>
    <li> 
      <P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"> 
        Как организуется доставка информации от компьютера-отправителя к компьютеру-получателю 
        через компьютеры-посредники? Как выбирается маршрут для передачи данных? 
        Какие стратегии закрепления используемых линий связи (сетевых ресурсов) 
        за взаимодействующими процессами могут быть использованы?</font></p>
    </li>
    <li> 
      <P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"> 
        Какие виды интерфейсов могут быть предоставлены операционными системами 
        для передачи информации по сети? Какие существуют модели взаимодействия 
        удаленных процессов? </font></p>
    </li>
  </ol>
</dir>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"> 
  Разумеется, степень важности этих вопросов во многом зависит от того, с какой 
  точки зрения мы подходим к рассмотрению общения удаленных процессов. Системного 
  программиста, в первую очередь, интересуют интерфейсы, предоставляемые операционными 
  системами. Сетевого администратора больше будут занимать вопросы адресации процессов 
  и выбора маршрута доставки данных. Проектировщика сетей в организации - способы 
  соединения компьютеров и обеспечения корректного использования разделяемых сетевых 
  ресурсов. Но так как мы подходим к этим вопросам с некоторых обобщенных позиций, 
  мы попробуем уделить им всем равное внимание. </font></p>
  
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"> 
  При рассмотрении поднятых проблем нельзя не учитывать и то, с какими сетями 
  мы имеем дело. Если в сеть объединены, к примеру, всего четыре вычислительных 
  комплекса, то проблемы адресации и выбора маршрута для передачи данных становятся 
  менее актуальными, чем проблема выбора конфигурации сети, так как они могут 
  быть решены относительно простыми средствами. Если же речь идет о сети, состоящей 
  из десятков тысяч компонентов, то приоритеты и сложность проблем меняются местами.</font></p>
<P ALIGN="JUSTIFY"><font face="Times New Roman, sans-serif, Courier, mono" size="3">В 
  литературе принято говорить о <i>локальных вычислительных сетях</i> (<i>LAN 
  - Local Area Network</i>) и <i>глобальных вычислительных сетях</i> (<i>WAN - 
  Wide Area Network</i>). При этом строгого определения этим понятиям обычно не 
  дается, а принадлежность сети к тому или иному типу часто определяется взаимным 
  расположением вычислительных комплексов, объединенных в сеть. Так, например, 
  в большинстве работ к локальным сетям относят сети, состоящие из компьютеров 
  одной организации, размещенные в пределах одного или нескольких зданий, а к 
  глобальным сетям - сети, охватывающие все компьютеры в нескольких городах и 
  более. Зачастую вводится дополнительный термин для описания сетей промежуточного 
  масштаба - <i>муниципальных </i>или<i> городских вычислительных сетей (MAN - 
  Metropolitan Area Network)</i> - сетей, объединяющих компьютеры различных организаций 
  в пределах одного города или одного городского района. Таким образом, упрощенно 
  можно рассматривать глобальные сети как сети, состоящие из локальных и муниципальных 
  сетей. А муниципальные сети, в свою очередь, могут состоять из нескольких локальных 
  сетей. На самом деле деление сетей на локальные, глобальные и муниципальные 
  обычно связано не столько с месторасположением и принадлежностью вычислительных 
  систем, соединенных сетью, сколько с различными подходами, применяемыми для 
  решения поставленных вопросов в рамках той или иной сети. Эти подходы мы частично 
  рассмотрим в последующих разделах, в которых постараемся по порядку ответить 
  на сформулированные выше вопросы.</font></p>
<P ALIGN="CENTER"> <B><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"><a name="l1405"></a>14.5. 
  Топология компьютерных сетей.</FONT></B> 
<P ALIGN="CENTER"> <B><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"><a name="l140501"></a>14.5.1 
  Топология локальных вычислительных сетей.</FONT></B> 
 
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"> 
  В локальной вычислительной сети, характеризующейся относительно небольшой протяженностью 
  недорогих и быстрых линий связи, компьютеры могут объединяться в сеть десятками 
  разнообразных способов. Количество и тип прокладываемых коммуникаций, то, какие 
  именно машины и как они будут соединять, - иными словами, топология вычислительной 
  сети - все это обычно определяется проектировщиками, исходя из трех основных 
  критериев:</FONT></P>
  
<dir> 
  <ul type="square">
    <li> 
      <P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"> 
        стоимость объединения вычислительных комплексов в сеть;</font> 
    </li>
    <li> 
      <P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"> 
        производительность сети (т.е. средняя скорость доставки данных от одного 
        компьютера к другому); </font> 
    </li>
    <li>
      <P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"> 
        надежность сети (как скажется на работе сети выход из строя одной из ее 
        компонент или одной линии связи). </font> 
    </li>
  </ul>
</dir>
  
  
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"> 
  Давайте кратко рассмотрим наиболее распространенные виды используемых топологий, 
  оценивая их по отношению к перечисленным критериям. </font> 
<P ALIGN="CENTER"> <B><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"><a name="l14050101"></a>14.5.1.1. 
  Сети с прямой связью всех компьютеров между собой.</FONT></B>
<P ALIGN="CENTER"> <B><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"><a name="l14050101a"></a>
  Полностью связанные сети.</FONT></B> 
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"> 
  Одной из сетевых топологий, упомянутых ранее и позволяющих каждому компьютеру 
  напрямую связаться с любым другим компьютером, являются полностью связанные 
  сети (см. <a href="#l14r1">рис.&nbsp;14.1.a</a>). В таких сетях каждый вычислительный 
  комплекс связан с каждым другим комплексом посредством отдельной физической 
  линии связи. Стоимость объединения вычислительных систем в такие сети весьма 
  велика (очень много линий связи!) и растет как квадрат числа комплексов. Однако 
  эта конфигурация имеет высокую скорость передачи данных по сети, минуя промежуточные 
  компоненты, и обладает высокой надежностью. Выход из строя одного компьютера 
  не влияет на работу оставшейся части сети. Выход из строя одной линии связи 
  (да и не только одной) все еще позволяет машинам связываться друг с другом, 
  правда уже не всегда напрямую. Надо заметить, что последнее свойство характерно 
  не только для полностью связанных сетей. Если в любой сети два компьютера входят 
  в некоторый цикл, образуемый линиями связи и, возможно, другими компьютерами, 
  то однократное повреждение этого цикла не приводит к потере возможности общения 
  таких компьютеров. Ограничениями для количества комплексов в полностью связанных 
  сетях являются финансовые возможности организатора сети и наличие мест для подключения 
  сетевых интерфейсов в этих комплексах.</FONT></P>
<P ALIGN="CENTER"> <B><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"><a name="l14050101b"></a> 
  Шины множественного доступа.</FONT></B> 
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"> 
  Второй сетевой топологией, обеспечивающей возможность прямого доступа одного 
  компьютера к другому, которую мы также упоминали в <a href="#l1403">разделе 
  14.3</a>, является организация сети на основе общей шины. Шины могут быть линейные 
  (<a href="#l14r1">см. рис. 14.1.b</a>) или кольцевые (<a href="#l14r1">см. рис. 
  14.1.c</a>). Стоимость таких сетей пропорциональна числу вычислительных машин, 
  объединенных сетью. Скорость передачи данных при небольшом количестве обменов 
  достаточно высока, однако в некоторых случаях (<a href="#l140601">как мы увидим 
  далее</a>) может резко падать с увеличением их числа. Выход из строя одного 
  компьютера не влияет на работу остальной части сети, но выход из строя самой 
  шины (а часто и разрыв подсоединения компьютера к шине) приводит к тому, что 
  все компьютеры начинают функционировать автономно. Количество комплексов в такой 
  сети в большей степени ограничивается падением ее производительности, чем финансовыми 
  соображениями. Известная сеть типа Ehternet относится к этой категории сетей. 
  </FONT></P>

  
<a name="l14r1"></a>
<table width="80%" border="0" cellspacing="1" cellpadding="1" align="center">
  <tr>
    <td  align="center"> 
     <img src="images/s14-1.jpg" width="162" height="135"> 
    </td>
    <td  align="center"> 
      <img src="images/s14-2.jpg" width="273" height="96"> 
    </td>
    <td  align="center" > 
       <img src="images/s14-3.jpg" width="263" height="243" align="middle"> 
	       </td>
  </tr>
  <tr>
    <td width="22%"> 
      <P ALIGN="center"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="2"> 
        a) Полностью связанная сеть </font></p>
    </td>
    <td width="42%"> 
      <P ALIGN="center"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="2"> 
        b) Сеть на основе линейной шины </font></p>
    </td>
    <td width="36%"> 
      <P ALIGN="center"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="2"> 
        c) Сеть на основе кольцевой шины </font></p>
    </td>
  </tr>
</table>

<P ALIGN="center"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="2">
Рис 14.1. Сети с прямой связью между всеми компьютерами.
</font></p>

<P ALIGN="CENTER"> <B><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"><a name="l14050102"></a>14.5.1.2. 
  Частично связанные сети.</FONT></B> 
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"> 
  Естественной альтернативой полностью связанным сетям и сетям, построенным на 
  основе общей шины, являются частично связанные сети, где прямые связи присутствуют 
  между некоторыми, но не всеми компонентами сети (<a href="#l14r2">см. рис. 14.2.</a>). 
  При этом обязана существовать возможность доступа от любого компьютера к любому 
  другому если не напрямую, то через некоторое количество посредников. Стоимость, 
  производительность и надежность таких сетей лежат где-то посередине между аналогичными 
  характеристиками для полностью связанных сетей и сетей, построенных на общей 
  шине. Далее мы рассмотрим некоторые важные частные случаи частично связанных 
  сетей.</FONT></P>
<P ALIGN="CENTER"> <B><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"><a name="l14050102a"></a> 
  Иерархические сети.</FONT></B> 
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"> 
  Иерархические сети являются одним из примеров частично связанных сетей. В иерархических 
  сетях компьютеры и линии связей между ними организуют дерево (<a href="#l14r2">см. рис. 14.2.a</a>.). 
  У каждого компьютера, за исключением главного компьютера, находящегося в вершине 
  дерева, есть свой компьютер-начальник, и может быть несколько (или ни одного) 
  компьютеров-подчиненных. Стоимость иерархической сети пропорциональна числу 
  компьютеров. При такой топологии подчиненный и непосредственный начальник могут 
  контактировать напрямую. Связь подчиненного с прямыми, но не непосредственными 
  начальниками построена на принципе субординации - по дороге необходимо пройти 
  через всех начальников меньшего уровня. Связь с другими подчиненными возможна 
  только через соответствующих начальников. Такая схема может быть удобна в иерархических 
  правительственных или коммерческих учреждениях. </FONT></P>
<P ALIGN="CENTER"> <B><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"><a name="l14050102b"></a>Кольцевые 
  сети.</FONT></B> 
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"> 
  Другим примером частично связанных сетей являются сети с кольцевой топологией. 
  В кольцевых сетях каждый комплекс соединен ровно с двумя другими комплексами 
  (<a href="#l14r2">см. рис. 14.2.b</a>). Связи между ними могут быть симплексными 
  для передачи информации только в одном направлении, образуя однонаправленное 
  кольцо, или дуплексными (полудуплексными), образуя двунаправленное кольцо. Стоимость 
  сети также пропорциональна числу вычислительных комплексов. Выход из строя одного 
  компьютера или обрыв одной связи в двунаправленном кольце оставляет сеть работоспособной. 
  По однонаправленной кольцевой схеме построено функционирование известной сети 
  Token Ring.</FONT></P>
<P ALIGN="CENTER"> <B><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"><a name="l14050102c"></a> 
  Звезды.</FONT></B> 
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"> 
  Последним примером топологии частично связанных сетей, из числа рассматриваемых 
  нами, являются сети типа "звезда". В таких сетях один выделенный компьютер соединен 
  прямыми связями с каждым из других компьютеров. Других связей в сети нет (<a href="#l14r2">см. 
  рис. 14.2.c</a>.). По своим свойствам такая топологическая схема близка к схеме 
  с общей шиной. Ее стоимость пропорциональна числу вычислительных машин. Выход 
  из строя любой линии связи или любого нецентрального комплекса не влияет на 
  работоспособность оставшейся части сети, в то время как поломка центрального 
  компьютера ведет к ее полному развалу.</FONT></P>
<a name="l14r2"></a> 
<table width="80%" border="0" cellspacing="1" cellpadding="1" align="center">
  <tr>
    <td width="22%" align="center"> <img src="images/s14-4.jpg" width="286" height="195"></td>
    <td width="42%" align="center"> <img src="images/s14-5.jpg" width="215" height="190"></td>
    <td width="36%" align="center" valign="middle"> <img src="images/s14-6.jpg" width="215" height="190"></td>
  </tr>
  <tr>
    <td width="22%"> 
<P ALIGN="center"><font face="Times New Roman, sans-serif, Courier, mono" size="2">a) 
  Иерархическая сеть</font></p>
    </td>
    <td width="42%"> 
<P ALIGN="center"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="2"> 
  b) Кольцевая сеть</font></p>
    </td>
    <td width="36%"> 
      <P ALIGN="center"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="2"> 
        c) Сеть типа "звезда" </font></p>
    </td>
  </tr>
</table>

<P ALIGN="center"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="2">
 Рис 14.2. Примеры частично связанных сетей
</font></p>

<P ALIGN="CENTER"> <B><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"><a name="l14050103"></a>14.5.1.3. 
Дополнительные устройства в локальных вычислительных сетях.</FONT></B> 
  
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"> 
  Мы уже говорили, что физические линии связи в локальных вычислительных сетях 
  отличаются относительно небольшой протяженностью и высокой скоростью передачи 
  данных. Одной из причин, ограничивающих их длину, является затухание сигнала 
  в физическом носителе информации по мере удаления от его источника. Для увеличения 
  возможного расстояния между двумя вычислительными комплексами, связанными напрямую 
  или подсоединенными к общей шине, применяют специальное устройство, получившие 
  название <i>повторитель</i> (<i>repeater</i>). Такое устройство встраивается 
  между двумя сегментами носителя данных и представляет собой обычный двунаправленный 
  усилитель физических сигналов (иногда повторители при этом осуществляют преобразование 
  сигналов из одной физической формы в другую). Применение повторителей позволяет 
  достаточно дешево повышать максимальную удаленность соединенных компьютеров. 
  К недостаткам повторителей необходимо отнести то, что они усиливают <u><b>все</b></u> 
  сигналы в линии связи, не только несущие полезную информацию, но и возникшие 
  побочные шумы. При использовании нескольких повторителей уровень шумов может 
  быть доведен до уровня полезного сигнала, что приведет к сбоям в работе сети. 
  <br>
  <br>
  Для отсечения помех и шумов в линиях связи применяют более сложные и дорогие 
  устройства, которые имеют представление о структуре передаваемых пакетов данных, 
  - <i>мосты</i> (<i>bridge</i>). Мосты, пользуясь внутренней заложенной в них 
  логикой, анализируют приходящие сигналы, выделяют из них корректные пакеты информации, 
  которые необходимо передать дальше, усиливают и передают через себя только эти 
  пакеты. Поскольку ретрансляция данных мостами происходит не на физическом, а 
  на логическом уровне, мостам проще, чем повторителям, соединять сегменты разнородных 
  каналов связи, преобразуя передаваемую информацию из одной физической формы 
  в другую.<br>
  <br>
  </font><font face="Times New Roman, sans-serif, Courier, mono" size="3">Развитие 
  современных технологий привело к появлению устройств, эмулирующих работу шин 
  множественного доступа, - <i>концентраторов</i> (<i>hub</i>). Вычислительные 
  комплексы в локальных сетях подключаются к таким устройствам с помощью различных 
  линий связи, более дешевых, чем собственно сами шины. Внешне конфигурация такой 
  сети выглядит как сеть типа &quot;звезда&quot; с использованием концентратора 
  вместо центрального выделенного сетевого компьютера, однако подобная сеть полностью 
  обладает свойствами, присущими сетям, организованным на базе общей шины. Пакет 
  информации, переданный на концентратор одним из комплексов, будет доступен всем 
  остальным компьютерам, подключенным к нему, как если бы он был передан по шине 
  множественного доступа. <br>
  <br>
  Более сложные модели концентраторов, получившие название <i>коммутаторов</i> 
  (<i>switch</i>), помимо эмуляции работы шины множественного доступа позволяют 
  управлять использованием этой виртуальной шины различными комплексами, задавая, 
  например, приоритеты для передачи информации независимо от ее получателя или 
  с его учетом.</font></p>
<P ALIGN="CENTER"> <B><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"><a name="l140502"></a>14.5.2.
   Соединение локальных вычислительных сетей между собой и их объединение в более масштабные сети. 
  </FONT></B> 
  
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"> 
  Казалось бы, соединить две локальные сети можно довольно просто - достаточно 
  лишь проложить линию связи между какими-нибудь двумя компьютерами, принадлежащими 
  к разным сетям. Однако этого недостаточно. Такое межсетевое соединение либо 
  должно включать в себя специальное устройство, которое мы будем называть <i>шлюзом</i> 
  (<i>gateway</i>), либо роль шлюза должен играть один из компьютеров, соединенных 
  межсетевой линией связи (см. рис 14.3). </font></p>
  
<table width="80%" align="center" border="0" cellspacing="0" cellpadding="0">
  <tr>
    <td><P ALIGN="center"> <img src="images/s14-7-1.jpg" width="277" height="224"></td>
    <td><P ALIGN="center"> <img src="images/s14-7-2.jpg" width="277" height="224"></td>
  </tr>
  <tr>
    <td><P ALIGN="center"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="2"> a) с использованием дополнительного устройства</font></td>
    <td><P ALIGN="center"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="2"> b) без использования дополнительного устройства </font></td>
  </tr>
</table>

<P ALIGN="center"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="2">Рис&nbsp;14.3. Пример соединения 2-х локальных сетей между собой. </font>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"> 
  Аналогичным образом, через шлюз, локальные сети могут подключаться к муниципальным 
  или глобальным сетям. <br>
  <br>
  Понятие муниципальных сетей появилось существенно позже понятия глобальных сетей. 
  Выделение сетей муниципального масштаба было связано с разработкой специального 
  стандарта - DQDB (Distributed Queue Dual Bus - распределенная двойная шина с 
  очередностью), описывающего топологию, форматы пакетов данных, способы обеспечения 
  взаимоисключений и т.п. для таких сетей. С топологической точки зрения муниципальные 
  сети представляют собой две однонаправленные шины, к которым напрямую подключаются 
  либо отдельные компьютеры (hosts - хосты), либо шлюзы локальных сетей (см. рис.14.4). 
  Шина A служит для передачи информации слева направо, а шина B - справа налево. 
  Протяженность таких шин может составлять несколько десятков километров при достаточно 
  высокой скорости обмена.</font></p>
<P ALIGN="center"><img src="images/s14-7-3.jpg" width="547" height="162">
<P ALIGN="center"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="2"> 
  Рис.&nbsp;14.4. Пример топологии муниципальной сети (MAN). </font> 
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"> 
  Глобальные вычислительные сети можно топологически представить себе как набор 
  специализированных компьютеров, часто называемых <i>переключателями пакетов</i> 
  <i>(packet switches)</i>, связанных между собой линиями связи большой протяженности, 
  к каждому из которых может быть подключено большое число отдельных компьютеров, 
  шлюзов локальных сетей или городские сети (см. рис. 14.5). Основным назначением 
  таких специализированных комплексов, как следует из их названия, является быстрое 
  определение дальнейшего маршрута следования пакета информации и его передача 
  с одной линии связи на другую. Для них применяют и другие названия: промежуточные 
  системы, коммутаторы данных, маршрутизаторы. Единой терминологии в данном случае 
  не существует. Топология связи переключателей пакетов между собой определяется 
  обычно исходя из тех же критериев, что и топология локальных вычислительных 
  сетей.</font></p>
  
<P ALIGN="center"><img src="images/s14-7-4.jpg" width="500" height="516">
<P ALIGN="center"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="2"> 
  Рис.&nbsp;14.5. Пример 
  фрагмента глобальной вычислительной сети. </font> 
<P ALIGN="CENTER"> <B><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"><a name="l1406"></a>14.6. 
  Взаимная синхронизация вычислительных комплексов.</FONT></B> 
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"> 
  Мы уже говорили, что любая линия связи в сети (независимо от того, локальная 
  это сеть, глобальная или промежуточного масштаба) является разделяемым ресурсом 
  для компьютеров, подключенных к ней. Поэтому, для корректной и эффективной ее 
  эксплуатации необходимо обеспечить взаимную синхронизацию этих компьютеров, 
  чтобы они не пытались использовать ее одновременно. Мы рассмотрим лишь несколько 
  алгоритмов такой взаимной синхронизации на примере сетей с общей шиной и кольцевых 
  сетей. Однако эти алгоритмы могут быть применены и в других топологических схемах.</font></p>
<P ALIGN="CENTER"> <B><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"><a name="l140601"></a>14.6.1. 
  Обнаружение коллизий (CSMA/CD).</FONT></B> 
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"> 
  Одним из методов обеспечения совместного использования линии связи является 
  метод обнаружения коллизий.<br>
  <br>
  Для того чтобы начать передавать пакет данных, каждый вычислительный комплекс, 
  подсоединенный к линии связи, должен быть уверен в том, что никакой другой компьютер 
  не ведет в это время передачу информации. Для этого перед началом передачи он 
  может прослушать линию связи и убедиться в отсутствии на ней данных. Если данные 
  присутствуют, то он ожидает освобождения линии. Такой прием получил название 
  <i>Carrier Sense with Multiple Access (прослушивание линии при множественном 
  доступе) </i> или сокращено <i>CSMA</i>. <br>
  <br>
  Так как скорость распространения сигнала по линии связи конечна, то в тот момент, 
  когда один компонент сети начал передачу пакета данных, другой может еще не 
  заметить их и тоже начать передавать информацию. Возникает коллизия. В результате 
  наложения физических сигналов друг на друга пакеты данных будут безнадежно искажены. 
  Для того чтобы избежать искажений, заставим передающий компьютер одновременно 
  с передачей считывать данные с линии и сравнивать то, что находится на ней, 
  с тем, что он передает. В случае несовпадения принятой и переданной информации 
  он будет регистрировать возникновение коллизии и прекращать передачу. Этот прием 
  получил название <i>Collision Detection (обнаружение коллизий) </i>или сокращено<i> 
  CD</i>. По прошествии некоторого промежутка времени (если, конечно, линия окажется 
  свободной) вычислительный комплекс сделает попытку возобновить передачу.<br>
  <br>
  Заметим, что время ожидания не может быть одинаковым для всех вычислительных 
  комплексов. Если один из них зарегистрировал коллизию, то и второй передающий 
  комплекс, скорее всего, тоже ее зарегистрирует. Если время ожидания будет одинаковым, 
  то, подождав немного, они убедятся, что линия свободна и снова оба начнут передавать. 
  Снова обнаружат коллизию, прервут передачу и так далее до бесконечности. Поэтому 
  время ожидания выбирается на каждом компоненте сети случайным образом. <br>
  <br>
  Весь предложенный метод синхронизации получил полное наименование <i>CSMA/CD</i>, 
  перевод которого на русский язык вы можете сделать самостоятельно. <br>
  <br>
  Метод CSMA/CD активно 
  используется в шинных сетях Ethernet. C ростом загруженности сети, число возникающих 
  коллизий будет увеличиваться. При этом производительность сети будет падать. 
  Начиная с определенной степени загруженности, производительность снижается катастрофически. 
  Поэтому число машин, которые могут быть подключены к одной шине Ethernet, приходится 
  ограничивать. Добавление одной новой машины к нормально функционирующей сети 
  Ethernet может привести к потрясающему замедлению всей работы. Обычно принятым 
  в практике разумным пределом считается число 16.</font></p>
  
<P ALIGN="CENTER"> <B><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"><a name="l140602"></a>14.6.2. 
  Метод передачи эстафетной палочки.</font></B> 
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"> 
  Другим методом взаимной синхронизации вычислительных комплексов является метод 
  передачи эстафетной палочки (token passing). Этот метод получил наибольшее распространение 
  в кольцевых однонаправленных сетях (скажем, в сетях Token Ring), на примере 
  которых мы его и рассмотрим.<br>
  <br>
  Наряду с пакетами данных по сети передается сообщение специальной структуры 
  - <i>token</i>. Компонент сети, принявший сообщение, анализирует его структуру. 
  В зависимости от того, что это за сообщение, поведение компонента определяется 
  следующим образом:</font></p>
<dir>
<ul type="square">
<li>
      <P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"> 
        Если это пакет данных, и он предназначен этому компоненту, то пакет изымается 
        из сети и поступает в дальнейшую обработку на принявшем его вычислительном 
        комплексе. </font>
    </li>
<li>
      <P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"> 
        Если это пакет данных, предназначенный другому компоненту, то он передается 
        следующему по кругу компоненту. </font> 
    </li>
  <li>
      <P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"> 
        Если компонент принял token и не желает передавать данные, то он передает 
        token, как эстафетную палочку, далее по кругу. </font>
    </li>
  <li>
      <P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"> 
        Если компонент принял token и желает передать пакет данных, то он сначала 
        передает своему соседу пакет данных, а затем вслед за ним отправляет token.</font> 
    </li>
  </ul></dir>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"> 
  При этом передача данных компонентом без принятия token'а запрещена.</font></p>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"> 
  Как видим, в такой сети разрешением на отправку данных является token, непрерывно 
  перемещающийся по кругу. Как и всякое другое сообщение, token имеет свойство 
  пропадать. В случае его потери сеть обнаруживает пропажу и возобновляет обращение 
  token'а. Обычно это происходит с помощью процесса выборов среди вычислительных 
  комплексов, победитель которых получает право сгенерировать новый token. Рассмотрение 
  алгоритмов проведения таких выборов, к сожалению, выходит за рамки нашего базового 
  курса операционных систем.</font></p>
<P ALIGN="JUSTIFY"><font face="Times New Roman, sans-serif, Courier, mono" size="3">Несколько 
  более сложное устройство метода эстафетной палочки увеличивает стоимость использующих 
  его сетей по сравнению со стоимостью сетей, использующих метод CSMA/CD. Однако 
  такие сети предсказуемо ведут себя с увеличением их размерности. Время передачи 
  эстафетной палочки по кругу при добавлении каждого нового компьютера увеличивается 
  на одну и ту же величину. При большой загруженности компьютеров в сети этот 
  способ обеспечивает большую производительность, чем CSMA/CD, при низкой загруженности 
  - ситуация становится противоположной.<br>
  </font></p>
<P ALIGN="CENTER"> <B><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"> 
  <a name="l140603"></a>14.6.3. Использование слотов для данных.</FONT></B> 
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"> 
  Использование слотов для данных является несколько модифицированным методом 
  эстафетной палочки. По сети (обычно кольцевой структуры) постоянно перемещаются 
  несколько сообщений, содержащих слоты фиксированной длины для размещения пакетов 
  данных. Сообщение может содержать данные в слоте, а может иметь пустой слот. 
  Передать информацию может только вычислительный комплекс, принявший сообщение 
  с пустым слотом, либо получивший сообщение с адресованными ему данными. В случае 
  пустого слота, компьютер помещает данные в слот и отправляет сообщение в сеть. 
  Вычислительный комплекс, принявший сообщение с предназначенным ему пакетом данных, 
  изымает данные из слота. Затем он может поместить в этот слот свои собственные 
  данные или отправить сообщение с пустым слотом далее по кругу. </FONT></P>
<P ALIGN="CENTER"><B><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"><a name="l1407"></a>14.7. 
  Проблемы адресации в сети.</FONT></B> </P>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Мы 
  с вами рассмотрели вопросы, связанные с топологическим строением сетей и обеспечением 
  взаимной синхронизации сетевых вычислительных комплексов, использующих общую 
  линию связи. При этом регулярно использовалось понятие &quot;пакет данных, адресованный 
  некоторому компоненту сети&quot;, т.е. фактически &quot;пакет данных, адресованный 
  какому-либо процессу или промежуточному объекту для накопления информации на 
  некотором компьютере&quot;. Несколько раньше, обсуждая отличия взаимодействия 
  удаленных процессов от взаимодействия локальных процессов, мы говорили, что 
  удаленные адресаты должны обладать уникальными адресами уже не в пределах одного 
  компьютера, а в пределах всей сети. Существует два подхода к наделению объектов 
  такими сетевыми адресами: одноуровневый и двухуровневый. </FONT></P>
<P ALIGN="CENTER"><B><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"><a name="l140701"></a>14.7.1. 
  Одноуровневые адреса.</FONT></B> 
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"> 
  В небольших локальных сетях можно построить одноуровневую систему адресации, 
  когда каждый процесс, желающий стать участником удаленного взаимодействия, (при 
  прямой адресации) и каждый объект, для такого взаимодействия предназначенный, 
  (при непрямой адресации) получают по мере необходимости свои собственные адреса 
  (символьные или числовые), а сами вычислительные комплексы, объединенные в сеть, 
  никаких самостоятельных адресов не имеют. Подобный подход требует довольно сложного 
  механизма обеспечения уникальности адресов. Вычислительный комплекс, на котором 
  запускается взаимодействующий процесс, должен запросить все компьютеры в сети 
  о возможности присвоения процессу некоторого адреса. Только после получения 
  от них согласия процессу может быть назначен адрес. Поскольку процесс, посылающий 
  данные другому процессу, не может знать на каком компоненте сети находится процесс-адресат, 
  то передаваемая информация должна быть направлена всем компонентам сети (так 
  называемое <i>широковещательное сообщение</i> - <i>broadcast message</i>), проанализирована 
  ими и либо отброшена (если процесс-адресат не находится на данном компьютере), 
  либо наконец-то доставлена по назначению. Так как данные должны постоянно передаваться 
  от одного комплекса ко всем остальным, такую одноуровневую схему обычно применяют 
  только в локальных сетях с прямой связью всех компьютеров между собой (например, 
  в сети NetBIOS на базе Ethernet), но она является существенно менее эффективной, 
  чем двухуровневая схема адресации. </font> 
<P ALIGN="CENTER"><B><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"><a name="l140702"></a>14.7.2. 
  Двухуровневые адреса.</FONT></B> 
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"> 
  </font> <FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">При 
  двухуровневой адресации полный сетевой адрес процесса или промежуточного объекта 
  для хранения данных складывается из двух частей - адреса вычислительного комплекса, 
  на котором находится процесс или объект, в сети (удаленного адреса) и адреса 
  самого процесса или объекта на этом вычислительном комплексе (локального адреса). 
  Уникальность полного адреса будет обеспечиваться уникальностью удаленного адреса 
  для каждого компьютера в сети и уникальностью локальных адресов объектов на 
  компьютере. Давайте подробнее рассмотрим проблемы, возникающие для каждой из 
  компонент полного адреса.</FONT> 
<P ALIGN="CENTER"><B><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"><a name="l14070201"></a>14.7.2.1. 
  Удаленная адресация и разрешение адресов.</FONT></B> 
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"> 
  Инициирующей причиной, побуждающей процессы связываться друг с другом, всегда 
  служит человек, будь то программист или обычный пользователь. Как мы не</FONT><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">однократно 
  отмечали в лекциях, человеку свойственно думать словами, он легче воспринимает 
  символьную информацию. Поэтому, очевидно, что каждая машина в сети получает 
  от людей свое символьное, часто даже содержательное, имя. Компьютер не разбирается 
  в смысловом содержании символов, ему проще оперировать числами, желательно одного 
  и того же формата, помещающимися, например в 4 байта или в 16 байт. Поэтому 
  каждый компьютер в сети для удобства работы вычислительных систем получает свой 
  числовой адрес. Возникает проблема отображения пространства символьных имен 
  (или адресов) вычислительных комплексов в пространство их числовых адресов. 
  Эта проблема получила наименование <i>проблемы разрешения адресов</i>.</FONT></P>
<P ALIGN="JUSTIFY"><font face="Times New Roman, sans-serif, Courier, mono" size="3">С 
  подобными проблемами мы уже сталкивались, обсуждая организацию памяти в вычислительных 
  системах (отображение имен переменных в их адреса в процессе компиляции и редактирования 
  связей) и организацию файловых систем (отображение имен файлов в их расположение 
  на диске). Посмотрим, как она может быть решена в своем сетевом варианте.</font></P>
<P ALIGN="JUSTIFY"><font face="Times New Roman, sans-serif, Courier, mono" size="3">Первый 
  способ решения заключается в том, что на каждом сетевом компьютере образовывается 
  файл, содержащий имена всех машин, доступных по сети, и их числовые эквиваленты. 
  Обращаясь к этому файлу, операционная система легко может перевести символьный 
  удаленный адрес в числовую форму. Такой подход применялся на заре существования 
  глобальных сетей и применяется в изолированных локальных сетях в настоящее время. 
  Действительно, легко поддерживать файл соответствий в корректном виде, внося 
  в него необходимые изменения, когда общее число сетевых машин не превышает несколько 
  десятков. Как правило, изменения вносятся на некотором выделенном административном 
  вычислительном комплексе, откуда затем обновленный файл рассылается по всем 
  компонентам сети. </font></P>
<P ALIGN="JUSTIFY"><font face="Times New Roman, sans-serif, Courier, mono" size="3">В 
  современной сетевой паутине этот подход является неприемлемым. Дело даже не 
  в размерах подобного файла, а в частоте требуемых обновлений и в огромном количестве 
  рассылок, что может полностью подорвать производительность сети. Проблема состоит 
  в том, что добавление или удаление компоненты сети требует внесения изменений 
  в файлы на всех сетевых машинах. Второй, альтернативный метод разрешения адресов 
  заключается в частичном распределении информации о соответствии символьных и 
  числовых адресов по многим комплексам сети, так что каждый из этих комплексов 
  содержит лишь часть полных данных. Он же определяет и правила построения символических 
  имен компьютеров. Подобный способ получил английское наименование <i>domain 
  name service</i> или сокращенно <i>DNS</i>. Его сокращенная аббревиатура широко 
  используется и в русскоязычной литературе. Давайте рассмотрим его подробнее. 
  </font></P>
<P ALIGN="JUSTIFY"><font face="Times New Roman, sans-serif, Courier, mono" size="3"> 
  Организуем логически все компьютеры в сети в некоторую древовидную структуру, 
  напоминающую директорную структуру файловых систем, в которых отсутствует возможность 
  организации жестких и мягких связей и нет пустых директорий. Будем рассматривать 
  все компьютеры, входящие во всемирную сеть, как область наинизшего ранга (аналог 
  корневой директории в файловой системе) - ранга 0. Разобьем все множество компьютеров 
  области на некоторое количество подобластей (domains). При этом некоторые подобласти 
  будут состоять из одного компьютера (аналоги файлов в файловых системах), а 
  некоторые - более чем из одного компьютера (аналоги поддиректорий в файловых 
  системах). Каждую подобласть будем рассматривать как область более высокого 
  ранга. Присвоим подобластям свои собственные имена таким образом, чтобы в рамках 
  разбиваемой области все они были уникальны. Повторим такое разбиение рекурсивно 
  для каждой области этого более высокого ранга, которая состоит более чем из 
  одного компьютера, несколько раз, пока при последнем разбиении в каждой подобласти 
  не окажется ровно по одному компьютеру. Глубина рекурсии для различных областей 
  одного ранга может быть различной, но обычно в целом ограничиваются 3-5 разбиениями, 
  начиная от ранга 0.</font></P>
<P ALIGN="JUSTIFY"><font face="Times New Roman, sans-serif, Courier, mono" size="3"> 
  В результате мы получим дерево, неименованной вершиной которого является область, 
  объединяющая все компьютеры, входящие во всемирную сеть, именованными терминальными 
  узлами - отдельные компьютеры (точнее - подобласти, состоящие из отдельных компьютеров), 
  а именованными нетерминальными узлами - области различных рангов. Используем 
  полученную структуру для построения имен компьютеров подобно тому, как мы поступали 
  при построении полных имен файлов в директорной структуре файловой системы, 
  только двигаясь от корневой вершины к терминальному узлу - отдельному компьютеру, 
  будем вести запись имен подобластей справа налево и отделять имена друг от друга 
  с помощью символа точка -&quot;.&quot;.</font></P>

<P ALIGN="JUSTIFY"><font face="Times New Roman, sans-serif, Courier, mono" size="3"> 
  Допустим, что некоторая подобласть, состоящая из одного компьютера, получила 
  имя <b><font color="#008000">serv</font></b>, она входит в подобласть, объединяющую 
  все компьютеры некоторой лаборатории, с именем <b><font color="#008000">crec</font></b>. 
  Та, в свою очередь, входит в подобласть всех компьютеров Московского физико-технического 
  института с именем <b><font color="#008000">mipt</font></b>, которая включается 
  в область ранга 1 всех компьютеров России с именем <b><font color="#008000">ru</font></b>. 
  Тогда имя рассматриваемого компьютера во всемирной сети будет <b><font color="#008000">serv.crec.mipt.ru</font></b>. 
  Аналогичным образом можно именовать и подобласти.</font></P>
<P ALIGN="JUSTIFY"><font face="Times New Roman, sans-serif, Courier, mono" size="3"> 
  В каждой полученной именованной области, состоящей более чем из одного узла, 
  выберем один из компьютеров и назначим его ответственным за эту область - <i>сервером 
  DNS</i>. Сервер DNS знает числовые адреса серверов DNS для подобластей, входящих 
  в его зону ответственности, или числовые адреса отдельных компьютеров, если 
  такая подобласть включает в себя только один компьютер. Кроме того, он также 
  знает числовой адрес сервера DNS, в зону ответственности которого входит рассматриваемая 
  область (если это не область ранга 1), или числовые адреса всех серверов DNS 
  ранга 1 (в противном случае). Отдельные компьютеры всегда знают числовые адреса 
  серверов DNS, которые за них непосредственно отвечают.</font></P>
<P ALIGN="JUSTIFY"><font face="Times New Roman, sans-serif, Courier, mono" size="3">Рассмотрим 
  теперь, как процесс на компьютере <b><font color="#008000">serv.crec.mipt.ru</font></b> 
  может узнать числовой адрес компьютера <b><font color="#008000">ssp.brown.edu</font></b>. 
  Для этого он обращается к своему DNS серверу, отвечающему за область <b><font color="#008000">crec.mipt.ru</font></b>, 
  и передает ему требуемый адрес в символьном виде. Если этот DNS сервер не может 
  сразу представить необходимый числовой адрес, он передает запрос DNS серверу, 
  отвечающему за область <b><font color="#008000">mipt.ru</font></b>. Если и тот 
  не в силах самостоятельно справиться с проблемой, он перенаправляет запрос серверу 
  DNS, отвечающему за область 1-го ранга <b><font color="#008000">ru</font></b>. 
  Этот сервер может обратиться к серверу DNS, обслуживающему область 1-го ранга 
  <b> <font color="#008000">edu</font></b>, который, наконец, затребует информацию 
  от сервера DNS области <b><font color="#008000">brown.edu</font></b>, где обязан 
  быть требуемый числовой адрес. Полученный числовой адрес по всей цепи серверов 
  DNS в обратном порядке будет передан процессу, направившему запрос (см. рис. 
  14.6.). </font></P>
<P ALIGN="center"><img src="images/s14-8.jpg" width="575" height="310"></P>
<P ALIGN="center"><font face="Times New Roman, sans-serif, Courier, mono" size="2"> 
  Рис. 14.6. Пример разрешения имен с использованием DNS серверов. </font></p>
<P ALIGN="JUSTIFY"><font face="Times New Roman, sans-serif, Courier, mono" size="3">В 
  действительности, каждый сервер DNS имеет достаточно большой кэш, содержащий 
  адреса серверов DNS для всех последних запросов. Поэтому реальная схема обычно 
  существенно проще, из приведенной цепочки общения DNS серверов выпадают многие 
  звенья за счет обращения напрямую.</font></P>
<P ALIGN="JUSTIFY"><font face="Times New Roman, sans-serif, Courier, mono" size="3">Рассмотренный 
  способ разрешения адресов позволяет легко добавлять компьютеры в сеть и исключать 
  их из сети, так как для этого необходимо внести изменения только на DNS сервере 
  соответствующей области. </font></P>
<P ALIGN="JUSTIFY"><font face="Times New Roman, sans-serif, Courier, mono" size="3">Если 
  DNS&nbsp;сервер, отвечающий за какую-либо область, выйдет из строя, то может 
  оказаться невозможным разрешение адресов для всех компьютеров этой области. 
  Поэтому обычно назначается не один сервер DNS, а два - основной и запасной. 
  При выходе из строя основного сервера, его функции немедленно начинает выполнять 
  запасной.</font></P>
<P ALIGN="JUSTIFY"><font face="Times New Roman, sans-serif, Courier, mono" size="3"> 
  В реальных сетевых вычислительных системах обычно используется комбинация рассмотренных 
  подходов. Для некоторых компьютеров, с которыми наиболее часто приходится устанавливать 
  связь, в специальном файле хранится таблица соответствий символьных и числовых 
  адресов. Все остальные адреса разрешаются с использованием службы DNS. <br>
  <br>
  Мы разобрались с проблемой удаленных адресов и знаем, как получить числовой 
  удаленный адрес нужного нам компьютера. Давайте разберемся теперь с проблемой 
  адресов локальных: как нам задать адрес процесса или объекта для хранения данных 
  на удаленном компьютере, который, в конечном итоге, и должен получить переданную 
  информацию.</font></P>

  
  
<P ALIGN="CENTER"> <B><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"><a name="l14070202"></a>14.7.2.2. 
  Локальная адресация. Понятие порта.</font></B> 
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"> 
  Во второй главе мы говорили, что каждый процесс, существующий в данный момент 
  в вычислительной системе, уже имеет свой собственный уникальный номер - PID. 
  Но этот номер не удобен в качестве локального адреса процесса при организации 
  удаленной связи. Номер, который получает процесс при своем рождении, определяется 
  моментом его запуска, предысторией работы вычислительного комплекса и является, 
  в значительной степени, случайным числом, изменяющимся от запуска к запуску. 
  Представьте себе, что адресат, с которым вы часто переписываетесь, постоянно 
  переезжает с место на место, меняя адреса, так что, посылая очередное письмо, 
  вы не можете с уверенностью сказать, где он сейчас проживает, и вы поймете все 
  неудобство использования идентификатора процесса в качестве его локального адреса. 
  Все сказанное выше справедливо и для идентификаторов промежуточных объектов, 
  использующихся при локальном взаимодействии процессов в схемах с непрямой адресацией.<br>
  <br>
  Для локальной адресации процессов и промежуточных объектов при удаленной связи 
  обычно организуется новое специальное адресное пространство, например, представляющее 
  собой ограниченный набор положительных целочисленных значений или множество 
  символических имен, аналогичных полным именам файлов в файловых системах. Каждый 
  процесс после своего рождения закрепляет за собой один или несколько адресов 
  в этом адресном пространстве. Каждому промежуточному объекту при его создании 
  присваивается свой адрес из этого адресного пространства. При этом удаленные 
  пользователи могут заранее договориться о том, какие именно адреса будут зарезервированы 
  для данного процесса, независимо от времени его старта, или для данного объекта, 
  независимо от момента его создания. Подобные адреса получили название <i>портов 
  </i> по аналогии с портами ввода-вывода. <br>
  <br>
  Необходимо отметить, что в системе может существовать несколько таких адресных 
  пространств для различных способов связи. При получении данных от удаленного 
  процесса операционная система смотрит, на какой порт и для какого способа связи 
  они были отправлены, определяет процесс, который заявил этот порт в качестве 
  своего адреса, или объект, которому присвоен этот адрес, и доставляет полученную 
  информацию адресату.</FONT></P>
<P ALIGN="CENTER"> <B><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"><a name="l14070203"></a>14.7.2.3. 
  Полные адреса. Понятие сокета (socket).</font></B> 
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Таким 
  образом, полный адрес удаленного процесса или промежуточного объекта для конкретного 
  способа связи с точки зрения операционных систем определяется парой адресов: 
  &lt;числовой адрес компьютера в сети, порт&gt;. Подобная пара получила наименование<i> 
  socket </i>(в русском переводе <i>гнездо</i> или, как стали писать в последнее 
  время, <i>сокет</i>), а сам способ их использования - <i>организация связи с 
  помощью socket'ов</i>. В случае непрямой адресации с использованием промежуточных 
  объектов сами эти объекты также принято называть сокетами. <br>
  <br>
  В современных сетевых системах числовой адрес обычно получает не сам вычислительный 
  комплекс, а его сетевой адаптер, с помощью которого комплекс подключается к 
  линии связи. При наличии нескольких сетевых адаптеров для разных линий связи 
  один и тот же вычислительный комплекс может иметь несколько числовых адресов. 
  В таких системах полные адреса удаленного адресата (процесса или промежуточного 
  объекта) задаются парами &lt;числовой адрес сетевого адаптера, порт&gt; и требуют 
  доставки информации через указанный сетевой адаптер.</font></P>
<P ALIGN="Center"><B><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"><a name="l1408"></a>14.8. 
  Проблемы маршрутизации и коммутации в сетях.</font></B> </P>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"> 
  При наличии прямой линии связи между двумя компьютерами обычно не возникает 
  вопросов о том, каким именно путем должна быть доставлена информация. Но как 
  мы упоминали, одним из отличий взаимодействия удаленных процессов от взаимодействия 
  процессов локальных является наличие, в большинстве случаев, процессов-посредников, 
  расположенных на вычислительных комплексах, не являющихся комплексами отправителя 
  и получателя. Рассматривая различные топологические схемы организации сетей, 
  мы видели, что физически информация между двумя компьютерами может быть часто 
  передана по различным путям. Возникает вопрос, как организовать работу операционных 
  систем на комплексах участниках связи (это могут быть конечные или промежуточные 
  комплексы) для определения маршрута передачи данных? По какой из нескольких 
  линий связи (или через какой сетевой адаптер) нужно отправить пакет информации? 
  Существует два принципиально разных подхода к решению этой проблемы: маршрутизация 
  от источника передачи данных и одношаговая маршрутизация. </FONT></P>
<dir>
  <ul type="square">
    <li>
      <P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"> 
        <i>Маршрутизация от источника передачи данных</i>. При маршрутизации от 
        источника данных полный маршрут передачи пакета по сети формируется на 
        компьютере-отправителе в виде последовательности числовых адресов сетевых 
        адаптеров, через которые должен пройти пакет, чтобы добраться до компьютера-получателя 
        и включается в состав этого пакета. В этом случае промежуточные компоненты сети при определении дальнейшего направления движения пакета не принимают самостоятельно никаких решений, а следуют указаниям, содержащимся в пакете.</font> 
    </li>
    <li> 
      <P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"> 
        <i>Одношаговая маршрутизация.</i> При одношаговой маршрутизации каждый 
        компонент сети, принимающий участие в передаче информации, самостоятельно 
        определяет, какому следующему компоненту, находящемуся в зоне прямого 
        доступа, она должна быть отправлена. Полный маршрут передачи данных складывается 
        из одношаговых решений, принятых компонентами сети.</font> 
    </li>


  </ul>
</dir>
<P ALIGN="JUSTIFY"> <FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"> 
  Маршрутизация от источника передачи данных весьма легко реализуется на промежуточных 
  компонентах сети, но требует полного знания маршрутов на конечных компонентах. 
  Она достаточно редко используется в современных сетевых системах, и далее мы 
  ее рассматривать не будем.</font></p>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Для 
  работы алгоритмов одношаговой маршрутизации на каждом компоненте сети, имеющем 
  возможность передавать информацию более чем одному другому компоненту, обычно 
  строится специальная таблица маршрутов. В простейшем случае каждая запись такой 
  таблицы содержит три данных: адрес вычислительного комплекса получателя; адрес 
  компонента сети, напрямую подсоединенного к данному, которому следует отправить 
  пакет, предназначенный для этого получателя; указание о том, по какой линии 
  связи (через какой сетевой адаптер) должен быть отправлен этот пакет. Поскольку 
  получателей в сети существует огромное количество, то для сокращения числа записей 
  в таблице маршрутизации обычно прибегают к двум специальным приемам. Во-первых, 
  числовые адреса топологически близко расположенных комплексов (например, комплексов, 
  принадлежащих одной локальной вычислительной сети) стараются выбирать из последовательного 
  диапазона адресов. В этом случае, запись в таблице маршрутизации может содержать 
  не адрес конкретного получателя, а диапазон этих адресов для некоторой сети 
  (номер сети). Во-вторых, если для очень многих получателей в качестве очередного 
  узла маршрута используется один и тот же компонент сети, а остальные маршруты 
  выбираются для ограниченного числа получателей, то в таблицу явно заносятся 
  только записи для этого небольшого количества получателей, а для маршрута, ведущего 
  к большей части всей сети, делается одна запись - маршрутизация по умолчанию 
  (default). Пример таблицы маршрутизации для комплекса A в сети, изображенной 
  на рисунке 14.7 приведен ниже:</font></p>
<FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"> 
<table width="80%" align="center" border="2" cellspacing="1" cellpadding="1">
  <tr align="center"> 
    <td width="33%">Адресат назначения</td>
    <td width="33%">Адрес очередного компонента</td>
    <td width="33%">Адрес исходящей линии связи</td>
  </tr>
  <tr align="center"> 
    <td width="33%">5-12</td>
    <td width="33%">20</td>
    <td width="33%">21</td>
  </tr>
  <tr align="center"> 
    <td width="33%">1-4</td>
    <td width="33%">15</td>
    <td width="33%">22</td>
  </tr>
  <tr align="center"> 
    <td width="33%">default</td>
    <td width="33%">28</td>
    <td width="33%">24</td>
  </tr>
</table>
</font> 
<P ALIGN="center"><a name="l1407ris147"></a><img src="images/s14-8-1.jpg" width="424" height="443"></P>
<P ALIGN="center"><font face="Times New Roman, sans-serif, Courier, mono" size="2"> 
  Рис. 14.7. Пример сети (адреса расставлены абстрактно). </font></p>

<P ALIGN="JUSTIFY">
<font face="Times New Roman, sans-serif, Courier, mono" size="3">По способам формирования 
и использования таблиц маршрутизации алгоритмы одношаговой маршрутизации можно 
разделить на три основных класса: 
<ul type="square">
  <li>алгоритмы фиксированной маршрутизации;</li>
  <li>алгоритмы простой маршрутизации;</li>
  <li>алгоритмы динамической маршрутизации.</li>
  </ul></font>
  
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"> 
  При <i>фиксированной маршрутизации</i> таблица, как правило, создается в процессе 
  загрузки операционной системы. Все записи в ней являются статическими. Линия 
  связи, которая будет использована для доставки информации от данного узла к 
  некоторому узлу A в сети, выбирается раз и навсегда. Обычно линии выбирают так, 
  чтобы минимизировать полное время доставки данных. Преимуществом этой стратегии 
  является простота ее реализации. Основной же ее недостаток заключается в том, 
  что при отказе выбранной линии связи данные не будут переданы, даже если существует 
  другой физический путь для их передачи.</font> 
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">В 
  алгоритмах <i>простой маршрутизации</i> таблица либо не используется совсем, 
  либо строится на основе анализа адресов отправителя приходящих пакетов информации. 
  Различают несколько видов простой маршрутизации - <i>случайную, лавинную и маршрутизацию 
  по прецедентам</i>. При случайной маршрутизации прибывший пакет отсылается в 
  первом попавшемся направлении, кроме исходного. При лавинной маршрутизации один 
  и тот же пакет рассылается по всем направлениям, кроме исходного. Случайная 
  и лавинная маршрутизации, естественно, не используют таблиц маршрутов. При маршрутизации 
  по прецедентам таблица маршрутизации строится по предыдущему опыту, исходя из 
  анализа адресов отправителей приходящих пакетов. Если прибывший пакет, адресован 
  компоненте сети, от которой когда-либо приходили данные, то соответствующая 
  запись об этом содержится в таблице маршрутов, и для дальнейшей передачи пакета 
  выбирается линия связи, указанная в таблице. Если такой записи нет, то пакет 
  может быть отослан случайным или лавинным способом. Алгоритмы простой маршрутизации 
  действительно просты по своей реализации, но отнюдь не гарантируют доставку 
  пакета указанному адресату в разумное время и по рациональному маршруту без 
  перегрузки сети.</font>
<P ALIGN="JUSTIFY"><font face="Times New Roman, sans-serif, Courier, mono" size="3">Наиболее 
  гибкими являются алгоритмы <i>динамической или адаптивной маршрутизации</i>, 
  которые умеют обновлять содержимое таблиц маршрутов на основе обработки специальных 
  сообщений, приходящих от других компонент сети, занимающихся маршрутизацией, 
  удовлетворяющих определенному протоколу. Такие алгоритмы принято делить на два 
  класса: <i>алгоритмы</i> <i>дистанционно-векторные</i> и <i>алгоритмы состояния 
  связей</i>. </font> 
<P ALIGN="JUSTIFY"><font face="Times New Roman, sans-serif, Courier, mono" size="3">При 
  дистанционно-векторной маршрутизации компоненты операционных систем на вычислительных 
  комплексах сети, занимающиеся выбором маршрута, (их принято называть <i>маршрутизатор</i> 
  или <i>router</i>) периодически обмениваются векторами, представляющими собой 
  информацию о расстояниях от данной компоненты до всех известных ей адресатов 
  в сети. Под расстоянием обычно понимается количество переходов между компонентами 
  сети (<i>hops</i>), которые необходимо сделать, чтобы достичь адресата, хотя 
  возможно существование и других метрик, включающих в себя скорость и/или стоимость 
  передачи пакета по линии связи. Рассмотрим более подробно работу алгоритма маршрутизации 
  для протокола RIP (Routing Information Protokol).</font> 
<P ALIGN="JUSTIFY"><font face="Times New Roman, sans-serif, Courier, mono" size="3">
<ol>
  <li>На первом этапе все маршрутизаторы строят свои минимальные таблицы маршрутизации, 
    содержащие информацию о компонентах сети, непосредственно подключенных к этим 
    маршрутизаторам. Для переключателя пакетов A на <a href="#l1407ris147">рисунке 
    14.7</a> такая таблица будет выглядеть так: <br>
    <br>
  </li>
  <table align="center" width="80%" border="2" cellspacing="1" cellpadding="1">
    <tr align="center"> 
      <td width="25%">Адресат назначения</td>
      <td width="25%">Адрес следующего маршрутизатора</td>
      <td width="25%">Адрес исходящей линии</td>
      <td width="25%">Расстояние</td>
    </tr>
    <tr align="center"> 
      <td>20,21</td>
      <td>-</td>
      <td>21</td>
      <td>1</td>
    </tr>
    <tr align="center"> 
      <td>15,22</td>
      <td>-</td>
      <td>22</td>
      <td>1</td>
    </tr>
    <tr align="center"> 
      <td>24,28</td>
      <td>-</td>
      <td>24</td>
      <td>1</td>
    </tr>
  </table>
  <br>
  А для шлюза Ш2 - так: <br>
  <br>
  <table align="center" width="80%" border="2" cellspacing="1" cellpadding="1">
    <tr align="center"> 
      <td width="25%"><font face="Times New Roman, sans-serif, Courier, mono" size="3">Адресат 
        назначения</font></td>
      <td width="25%"><font face="Times New Roman, sans-serif, Courier, mono" size="3">Адрес 
        следующего маршрутизатора</font></td>
      <td width="25%"><font face="Times New Roman, sans-serif, Courier, mono" size="3">Адрес 
        исходящей линии</font></td>
      <td width="25%"><font face="Times New Roman, sans-serif, Courier, mono" size="3">Расстояние</font></td>
    </tr>
    <tr align="center"> 
      <td><font face="Times New Roman, sans-serif, Courier, mono" size="3">5-12,13</font></td>
      <td><font face="Times New Roman, sans-serif, Courier, mono" size="3">-</font></td>
      <td><font face="Times New Roman, sans-serif, Courier, mono" size="3">13</font></td>
      <td><font face="Times New Roman, sans-serif, Courier, mono" size="3">1</font></td>
    </tr>
    <tr align="center"> 
      <td>20,21</td>
      <td>-</td>
      <td>20</td>
      <td>1</td>
    </tr>
  </table>
  <br>
  <li>На втором этапе маршрутизаторы рассылают свои минимальные таблицы всем маршрутизаторам, 
    непосредственно к ним подсоединенным.</li>
  <li>На третьем этапе маршрутизаторы получают аналогичные таблицы от соседей, 
    наращивают каждое полученное в них поле метрики на 1 и запоминают, от кого 
    и через какую линию связи была получена новая информация. После чего начинают 
    сравнивать новые данные с теми, что уже находятся в таблице маршрутов. Для 
    шлюза Ш2 новая информация, полученная от переключателя пакетов A, располагается 
    в строках 4-6 таблицы, приведенной ниже: <br>
    <br><font face="Times New Roman, sans-serif, Courier, mono" size="3"> 
    <table align="center" width="80%" border="2" cellspacing="1" cellpadding="1">
  <tr align="center"> 
    <td width="25%"><font face="Times New Roman, sans-serif, Courier, mono" size="3">Адресат 
      назначения</font></td>
    <td width="25%"><font face="Times New Roman, sans-serif, Courier, mono" size="3">Адрес 
      следующего маршрутизатора</font></td>
    <td width="25%"><font face="Times New Roman, sans-serif, Courier, mono" size="3">Адрес 
      исходящей линии</font></td>
    <td width="25%"><font face="Times New Roman, sans-serif, Courier, mono" size="3">Расстояние</font></td>
  </tr>
  <tr align="center"> 
    <td><font face="Times New Roman, sans-serif, Courier, mono" size="3">5-12,13</font></td>
    <td><font face="Times New Roman, sans-serif, Courier, mono" size="3">-</font></td>
    <td><font face="Times New Roman, sans-serif, Courier, mono" size="3">13</font></td>
    <td><font face="Times New Roman, sans-serif, Courier, mono" size="3">1</font></td>
  </tr>
  <tr align="center"> 
    <td>20,21</td>
    <td>-</td>
    <td>20</td>
    <td>1</td>
  </tr>
  <tr align="center"> 
    <td><s>20,21</s></td>
    <td><s>21</s></td>
    <td><s>20</s></td>
    <td><s>2</s></td>
  </tr>
  <tr align="center"> 
    <td>15,22</td>
    <td>21</td>
    <td>20</td>
    <td>2</td>
  </tr>
  <tr align="center"> 
    <td>24,28</td>
    <td>21</td>
    <td>20</td>
    <td>2</td>
  </tr>
</table><br>
    Строки 5 и 6 содержат данные об адресатах еще не известных шлюзу Ш2 и поэтому 
    будут оставлены в таблице маршрутов. Строка 4 содержит информацию об известных 
    адресатах с метрикой хуже уже существовавшей, поэтому она не будет включена 
    в таблицу маршрутизации. Если бы метрика для известного адресата в новых данных 
    была лучше, то новая запись заместила бы старую запись.</font> </li>
	
  <li>Этапы 2 и 3 повторяются периодически для обновленных таблиц маршрутизации, 
    постепенно распространяя информацию об адресатах по всей сети.</li>

</ol></font>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Для 
  того чтобы можно было изменять таблицы маршрутизации в случае выхода из строя 
  какой-либо линии связи или какого-либо компонента сети, дополнительно используются 
  два приема: старение данных о маршруте и указание специального расстояния (бесконечности) 
  до компонентов сети, ставших недоступными. Для первого из этих приемов каждая 
  запись о маршруте в таблице маршрутизации, не входившая в минимальную таблицу, 
  снабжается дополнительным полем - временем жизни маршрута. При получении информации 
  о маршруте от другого маршрутизатора время его жизни устанавливается в некоторое 
  значение, которое затем уменьшается на 1 каждую секунду. Если до достижения 
  нулевого значения маршрут не подтверждается маршрутизатором, приславшим его, 
  то запись считается устаревшей и удаляется из таблицы. Первый прием используется 
  в том случае если в результате потери работоспособности линии связи или компонента 
  сети маршрутизатор не может рассылать RIP сообщения. Второй прием применяется 
  в случае, когда RIP сообщения могут быть переданы. Для недоступных компонент 
  сети маршрутизатор указывает специальное значение метрики, считающееся бесконечностью 
  (например, 16). Получив информацию с бесконечной метрикой для некоторого адресата, 
  маршрутизатор проверяет, исходит ли оно из того же источника, что и уже существовавший 
  маршрут. Если да, то сообщение считается достоверным, и маршрут помечается как 
  недействительный. </font></p>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">RIP 
  протокол обеспечивает достаточно разумную маршрутизацию пакетов, но не может 
  предотвратить возможность возникновения маршрутных петель. Именно из-за этого 
  значение бесконечности выбрано относительно небольшим. Поэтому RIP машрутизация 
  может быть эффективно использована только в относительно небольших сетях. Для 
  больших сетей применяются алгоритмы состояния связей, которые на каждом маршрутизаторе 
  строят графы сети, в качестве узлов которого выступают ее компоненты, а в качестве 
  ребер, обладающих стоимостью, существующие между ними линии связи. Недостаток 
  времени не позволяет нам подробнее остановиться на этих алгоритмах.</font></p>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">Обычно 
  вычислительные сети используют смесь различных стратегий маршрутизации. Для 
  некоторых адресов назначения может использоваться фиксированная маршрутизация, 
  для некоторых - простая, для некоторых - динамическая. В локальных вычислительных 
  сетях обычно используются алгоритмы фиксированной маршрутизации, в отличие от 
  глобальных вычислительных сетей, в которых в основном применяют алгоритмы адаптивной 
  маршрутизации. <br>
  <br>
  К проблемам маршрутизации тесно примыкают проблемы коммутации сетей. Могут ли 
  другие процессы использовать линии связи, по которым уже происходит общение 
  удаленных процессов? Здесь также возможны три подхода.</font></p>
<dir>
<ul type="square">
<li>
      <P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"> 
        <i>Сети с коммутацией цепей.</i> Линии связи, по которым общаются между 
        собой два удаленных процесса, становятся недоступными на все время сеанса 
        связи для всех других процессов, даже если в данный момент не происходит 
        активного общения. Общение в таких сетях напоминает общение по телефону. 
        Телефонная линия во время разговора недоступна для других абонентов, даже 
        если участники разговора длительное время молчат.</font> 
    </li>
<li>
      <P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"> 
        <i>Сети с коммутацией сообщений.</i> Линии связи блокируются на время 
        передачи одного логического сообщения между двумя процессами. Этот подход 
        напоминает переписку адресатов по почте. Одна та же линия связи может 
        быть использована для пересылки многих писем от различных людей одновременно.</font> 
    </li>
<li>
      <P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"> 
        <i>Сети с коммутацией пакетов.</i> Логические сообщения могут быть достаточно 
        объемными, поэтому очень часто их разбивают на пакеты данных фиксированной 
        длины - <i>фрагментируют</i>. Каждый такой пакет может рассматриваться 
        как своего рода минисообщение, из которых на узле получателе информации 
        восстанавливается (<i>дефрагметируется</i>) исходное сообщение. Естественно, 
        что при передаче пакета данных по линии связи обеспечивается взаимная 
        синхронизация узлов, подключенных к этой линии, которую мы обсуждали ранее 
        (то есть линия блокируется на время передачи одного пакета информации).</font> 
    </li>
</ul></dir>

<P ALIGN="Center"><B><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"> 
  <a name="l1409"></a>14.9. Связь с установлением логического соединения и передача 
  данных с помощью сообщений.</font></B> </P>
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"> 
  Обсуждая отличия взаимодействия локальных и удаленных процессов, мы в качестве 
  одного из основных отличий упомянули, что в основе всех средств связи на автономном 
  компьютере так или иначе лежит механизм совместного использования памяти, в 
  то время, как в основе всех средств связи между удаленными процессами лежит 
  передача сообщений. Неудивительно, что количество категорий средств удаленной 
  связи сокращается до одной - канальных средств связи. Обеспечивать интерфейс 
  для сигнальных средств связи и разделяемой памяти, базируясь на передаче пакетов 
  данных, становится слишком трудоемко и дорого. <br>
  <br>
  Рассматривая канальные средства связи для локальных процессов в главе 4, мы 
  говорили о существовании двух моделей передачи данных по каналам связи: поток 
  ввода-вывода и сообщения. Для общения удаленных процессов применяются обе эти 
  модели, однако теперь уже более простой моделью становится передача информации 
  с помощью сообщений.<br><br>
  Средства связи удаленных процессов, интерфейс которых предназначен для обмена 
  сообщениями, получили наименование <i>средств связи без установления логического 
  соединения </i>(<i>connectionless</i>) или <i>средств обмена датаграммами</i>, 
  поскольку само сообщение здесь принято называть <i>датаграммой</i> (<i>datagramm</i>) 
  или <i>дейтаграммой</i>. Каждое сообщение адресуется и посылается процессом 
  индивидуально. С точки зрения операционных систем все датаграммы - это независимые 
  единицы, не имеющие ничего общего с другими датаграммами, которыми обмениваются 
  эти же процессы. <br>
  <br>
  Необходимо отметить, что с точки зрения процессов, обменивающихся информацией, 
  датаграммы, конечно, могут быть связаны по содержанию друг с другом, но ответственность 
  за установление и поддержание этой семантической связи лежит не на операционных 
  системах, а на самих взаимодействующих процессах. <br>
  <br>
  По-другому обстоит дело со средствами связи, интерфейс которых поддерживает 
  потоковую модель. Они получили наименование <i>средств связи, требующих установления 
  логического соединения</i> (<i>connection-oriented</i>). Хотя в их основе по 
  прежнему лежит передача данных с помощью пакетов информации, но операционные 
  системы сами нарезают эти пакеты из передаваемого потока данных, организовывают 
  правильную последовательность их безошибочного получения, и снова объединяют 
  полученные пакеты в поток, так что с точки зрения взаимодействующих процессов 
  после установления логического соединения они имеют дело с потоковым средством 
  связи, напоминающим pipe или FIFO. <br>
  <br>
  И те, и другие средства связи обычно используют в своей работе одни и те же 
  физические носители и рассмотренные выше способы адресации, маршрутизации и 
  коммутации сетей.</FONT></P>
  
  
<P ALIGN="Center"><B><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"> 
  <a name="l1410"></a>14.10. Многоуровневая модель построения сетевых вычислительных 
  систем.</font></B></P>
  
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"> 
  Из проведенного анализа проблем, связанных с организацией взаимодействия удаленных 
  процессов, видно, что построение сетевых средств связи существенно более сложная 
  задача, чем реализация локальных средств связи. Поэтому обычно задачу создания 
  таких средств решают по частям, применяя уже неоднократно упоминавшийся нами 
  слоеный подход.<br>
  <br>
  Как уже отмечалось при обсуждении слоеного строения операционных систем на первой 
  лекции, в таких системах уровень N предоставляет сервисы уровню N+1, пользуясь 
  в свою очередь только сервисами уровня N-1. Следовательно, каждый уровень может 
  взаимодействовать непосредственно только со своими соседями через четко определенные 
  интерфейсы - вертикальные протоколы. <br>
  <br>
  Реальная физическая связь между различными вычислительными системами реализуется 
  только на самом нижнем уровне тоже с помощью некоторого протокола. Все остальные 
  одноименные уровни виртуально обмениваются данными посредством других горизонтальных 
  протоколов. Наличие такой виртуальной связи означает, что уровень N компьютера 
  2 должен получить ту же самую информацию, которая была отправлена уровнем N 
  компьютера 1, хотя в реальности эта информация должна была сначала дойти сверху 
  вниз до уровня 1 компьютера 1, затем реально передана уровню 1 компьютера 2, 
  и только после этого доставлена снизу вверх уровню N этого компьютера.<br>
  <br>
  Наличие большого количества вертикальных и горизонтальных протоколов в сетевых 
  системах, построенных по слоеному принципу, привело к тому, что эти системы 
  стали называть системами, реализующими определенное <i>семейство протоколов</i> 
  или <i>стек протоколов</i>.<br>
  <br>
  Эталоном многоуровневой схемы построения сетевых средств связи принято считать 
  семиуровневую модель открытого взаимодействия систем (Open System Interconnection 
  или OSI), предложенную Международной Организацией Стандартов (International 
  Standard Organization или ISO), получившую сокращенное наименование OSI/ISO 
  (см. рис. 14.9.). </font></p>
<P ALIGN="center"><img src="images/s14-9.jpg" width="459" height="397">
 <P ALIGN="center"><font face="Times New Roman, sans-serif, Courier, mono" size="2">
Рис. 14.9. Семиуровневая эталонная модель OSI/ISO.
</font></p>
 <P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3">
  Давайте подробнее рассмотрим, какие сервисы предоставляют различные уровни модели 
  OSI/ISO:</font></p>
  <dir><ul type="square">
  <li>
      <P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"> 
        Уровень 1 - <i>физический</i>. Этот уровень связан с работой hardware. 
        На нем определяются физические аспекты передачи информации по линиям связи, 
        такие как напряжения, частоты, природа передающей среды, способ передачи 
        двоичной информации по физическому носителю, вплоть до размеров и формы 
        используемых разъемов. </font> 
    </li>
  <li>
      <P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"> 
        Уровень 2 - <i>канальный</i>. Этот уровень представляет собой программный 
        интерфейс к физическому уровню. На нем обычно находятся драйверы сетевых 
        устройств ввода-вывода. Он отвечает за передачу данных по физическому 
        уровню без искажений между непосредственно связанными узлами сети. Основной 
        его задачей является обеспечение надежной связи между такими узлами, независимой 
        от ее конкретной физической реализации.</font>
    </li>
  <li>
      <P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"> 
        Уровень 3 - <i>сетевой</i>. Сетевой уровень отвечает за доставку информации 
        от узла отправителя к узлу получателю. На этом уровне решаются вопросы 
        удаленной адресации, маршрутизации, осуществляется фрагментация и дефрагментация 
        пакетов данных, а также управление скоростью передачи информации для предотвращения 
        перегрузок в сети.</font> 
    </li>
  <li>
      <P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"> 
        Уровень 4 - <i>транспортный</i>. Регламентирует передачу данных между 
        удаленными процессами, определяет локальные адреса удаленных процессов. 
        Компенсирует ненадежность нижележащих уровней, за счет обработки ошибок, 
        связанных с искажением пакетов данных, их потерей и доставкой в ненадлежащем 
        порядке. Наряду с сетевым уровнем может управлять скоростью передачи данных.</font> 
    </li>
  <li>
      <P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"> 
        Уровень 5 - <i>сеансовый</i>. Координирует взаимодействие связывающихся 
        процессов. Он добавляет к транспортному уровню такие сервисы, как установление 
        и завершение сеанса связи удаленных процессов (например, вход в систему 
        и выход из нее), отвечает за преобразование адресов из символьного вида 
        в числовой и обратно и т.д.</font> 
    </li>
  <li>
      <P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"> 
        Уровень 6 - уровень <i>представления данных</i>. Отвечает за форму представления 
        данных, перекодирует текстовую и графическую информацию из одного формата 
        в другой, обеспечивает ее сжатие и распаковку.</font>
    </li>
  <li>
      <P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"> 
        Уровень 7 - <i>прикладной</i>. Служит для организации интерфейса между 
        пользователем и сетью. На этом уровне реализуются такие сервисы, как удаленная 
        передача данных, удаленный терминальный доступ, почтовая служба и работа 
        во всемирной паутине (Web-браузеры).</font> 
    </li>
  </ul></dir>
  
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"> 
  Надо отметить, что к приведенной эталонной модели следует относиться без излишнего 
  пиетета. Эта модель не предвосхитила появления различных семейств протоколов, 
  таких как, например, семейство протоколов TCP/IP, а наоборот была создана под 
  их влиянием. Ее не следует рассматривать, как готовый оптимальный чертеж для 
  создания любого сетевого средства связи. Наличие некоторой функции на определенном 
  уровне не гарантирует, что это ее наилучшее место, некоторые функции (например, 
  коррекция ошибок) дублируются на нескольких уровнях, да и само деление на 7 
  уровней носит достаточно произвольный характер. Хотя, в конце концов, были созданы 
  работающие реализации этой модели, наиболее распространенные семейства протоколов 
  лишь отчасти согласуются с ней. Как отмечено в книге Танненбаума, она более 
  пригодна для реализации телефонных, а не вычислительных сетей.</font></p>
<P ALIGN="JUSTIFY"><font face="Times New Roman, sans-serif, Courier, mono" size="3">Сети, 
  построенные на основе разных стеков протоколов, могут быть объединены между 
  собой с использованием вычислительных устройств, осуществляющих трансляцию из 
  одного стека протоколов в другой, причем на различных уровнях слоеной модели. 
  Подобные устройства и получают название шлюзов, о необходимости которых мы говорили, 
  обсуждая объединение локальных вычислительных сетей.</font></p>
<P ALIGN="CENTER"> <B><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"> 
  <a name="l1411"></a>14.11. Синхронизация удаленных процессов.</FONT></B> 
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"> 
  Мы с вами обсудили основные принципы логической организации сетевых средств 
  связи, внешние по отношению к взаимодействующим процессам. Однако, как мы обсуждали 
  в <a href="../05/l5.htm">главе 5</a>, для корректной работы таких процессов, 
  необходимо обеспечить определенную их синхронизацию, которая устранила бы возникновение 
  race condition на их соответствующих критических участках. Удаленность процессов 
  накладывает определенный отпечаток и на организацию такой синхронизации. К сожалению, 
  из-за ограниченности объема нашего курса мы не можем остановиться здесь на этих 
  вопросах и вынуждены отсылать интересующихся к литературе, например к <a href="../literature/literature.htm">[8]</a> 
  или к <a href="../literature/literature.htm">[12]</a></font></p>
<P ALIGN="CENTER"> <B><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"><a name="l1412"></a>14.12. 
  Резюме.</FONT></B> 
<P ALIGN="JUSTIFY"><FONT FACE="Times New Roman, sans-serif, Courier, mono" size="3"> 
  Основными причинами объединения компьютеров в вычислительные сети являются <a href="#l1401">потребности 
  в разделении ресурсов, ускорении вычислений, повышении надежности и облегчении 
  общения пользователей.</a><br><br>
  Вычислительные комплексы в сети могут находиться под управлением <a href="#l1402">сетевых или 
  распределенных операционных систем</a>. Основой для объединения компьютеров в 
  сеть служит взаимодействие удаленных процессов. При рассмотрении вопросов организации 
  взаимодействия удаленных процессов нужно принимать во внимание <a href="#l1403">основные отличия 
  их кооперации от кооперации локальных процессов</a>. <br><br>
  Базой для взаимодействия локальных процессов служит организация общей памяти, 
  в то время как для удаленных процессов - это обмен пакетами данных. <br><br>Вычислительные 
  комплексы при работе в сети должны обеспечивать синхронизацию использования 
  общих линий связи, например, с помощью методов <a href="#l140601">CSMA/CD</a>, <a href="#l140602">передачи эстафетной 
  палочки (token passing)</a> или <a href="#l140603">использования слотов для сообщений</a>.<br>
  <br>
  Удаленные процессы, в отличие от локальных, обычно требуют <a href="#l140702">двухуровневой адресации</a>
  при своем общении. Полный адрес процесса состоит из двух частей: удаленной и 
  локальной. Для удаленной адресации используются символьные и числовые имена 
  узлов сети. Перевод имен из одной формы в другую (разрешение имен) может осуществляться 
 <a href="#l14070201">с помощью централизованно обновляемых таблиц соответствия полностью на каждом 
  узле или с использованием выделения зон ответственности серверов DNS</a>. Для локальной 
  адресации процессов используются <a href="#l14070202">адресные пространства портов</a>. Упорядоченная пара из адреса 
  узла в сети и адреса порта получила название <a href="#l14070203">socket</a>.<br>
  <br>
  Вычислительные комплексы могут топологически объединяться по-разному: <a href="#l14050101a">в полностью 
  связанные сети</a>, <a href="#l14050102a">иерархические сети</a>, 
  <a href="#l14050102c">звезды</a>, <a href="#l14050102b">кольца</a>, использовать 
  <a href="#l14050101b">общую шину</a>. 
  Для доставки сообщения от одного узла к другому могут использоваться разные 
  <a href="#l1408">стратегии маршрутизации и коммутации</a>. С точки зрения процессов обмен информацией 
  может осуществляться в <a href="#l1409">форме датаграмм или потока данных</a><br>
  <br>
  Сетевые средства связи обычно строятся по слоеному принципу, используя при своей 
  работе <a href="#l1410">семейства (стеки) строго определенных вертикальных и горизонтальных протоколов</a>. 
  <br>
  <br>
  Как и всякие кооперативные процессы, удаленные процессы при своей работе требуют 
  синхронизации при прохождении критических участков. В общем случае проблема 
  достижения согласованного решения набором ненадежных удаленных процессов при 
  ненадежных средствах связи является неразрешимой.<br>
  <br>
  
  </FONT></P>
<p align="center"><a href="../12/ch12.htm"> Предыдущая глава</a> | 
<a href="../os.html">Программа курса</a> | 
<a href="../15/ch15.htm"> Следующая глава</a></p>

</BODY>
</HTML>
